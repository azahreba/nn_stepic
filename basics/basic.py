import numpy as np

# python3 -m pip install --upgrade pip
# pip3 install --user numpy

# array(object) — n-мерный массив из любой (возможно, вложенной) последовательности,
# eye(N, M=N, k=0) -- двумерный массив с N строками с единицами на диагонали и нулями во всех остальных позициях. Число столбцов M по умолчанию равно N, k — сдвиг диагонали (0 для основной диагонали, положительные числа для верхних диагоналей и отрицательные для нижних),
# zeros(shape) -- новый массив указанной формы, заполненный нулями,
# ones(shape) -- новый массив указанной формы, заполненный единицами,
# full(shape, fill_value) -- новый массив указанной формы, заполненный fill_value.

# print(np.eye(5, 3, k=-1))

# в NumPy используется стандартное  выделение подмножеств:
# a[start:stop:step] выбирает элементы из a с индексами от start до stop с шагом step,
# т.е. a[start], a[start + step], a[start + 2*step] и так далее,
# пока индексы меньше stop; при step = 1 этот параметр можно опустить,
# оставив start:stop, при start, равном минимальному индексу в массиве, или stop, равному максимальному индексу,
# эти индексы также можно опустить: это будет выглядеть как a[:];
# отрицательные индексы;
# поддерживается синтаксис многоточия: a[..., 1] выбирает элементы с любым индексом в первом измерении и с индексом, равным 1, во втором измерении:  a[:, 1] оказывается эквивалентно a[..., 1];
# можно указать индексы сразу в нескольких измерениях, указав их через запятую в квадратных скобках (как a[..., 1] в примере выше).

a = np.array([[1,2,3], [4,5,6]])  # создаём массив
print(a)  # смотрим на массив
print(a.shape)  # смотрим на форму массива
mat = np.eye(3, 4, 1) + (np.eye(3, 4)*2)
print(mat);

# a.flatten() — превращает массив в одномерный.
# a.T или a.transpose(*axes) — транспонирование (или смена порядка осей в случае, когда размерность массива больше двух).
# a.reshape(shape) — смена формы массива. Массив "распрямляется" и построчно заполняется в новую форму.

# import random
# w = np.array(random.sample(range(1000), 12))
# w = )
# print(w.reshape((2,2,3))) # превратим w в трёхмерную матрицу
# print(w.transpose(0,2,1))

mat = mat.flatten()

print('mat: ', mat.size)
print('shape: ', mat.reshape(mat.size, 1));

# a.min(axis=None), a.max(axis=None), — минимум, максимум,
# a.mean(axis=None), a.std(axis=None) - среднее арифметическое и стандартное отклонение вдоль указанной оси.
# По умолчанию ось не указана и статистика считается по всему массиву.
# a.argmin(axis=None), a.argmax(axis=None) — индексы минимального и максимального элемента.

v = np.array([ [1,2,3], [4,5,6], [7,8,9] ])

print(v.mean(axis=0))  # вдоль столбцов
print(v.mean(axis=1))
print(v.mean(axis=None));

# a.sum(axis=None), a.prod(axis=None) — сумма и произведение всех элементов вдоль указанной оси.
# a.cumsum(axis=None), a.cumprod(axis=None) — частичные суммы и произведения (для (a1,⋯,an)(a1,⋯,an)
# вектор частичных сумм — это (a1,a1+a2,⋯,a1+⋯+an)(a1,a1+a2,⋯,a1+⋯+an)).

# a.dot(b) — матричное произведение двух массивов (размерности должны быть согласованы),
# linalg.matrix_power(M, n) — возведение матрицы M в степень n,
# a.T — транспонирование
# linalg.norm(a, ord=None) — норма матрицы
# linalg.inv(a) — матрица, обратная к a (если a необратима, выбрасывается LinAlgError; псевдообратная считается через linalg.pinv(a))