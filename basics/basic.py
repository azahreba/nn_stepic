import numpy as np

# python3 -m pip install --upgrade pip
# pip3 install --user numpy

# array(object) — n-мерный массив из любой (возможно, вложенной) последовательности,
# eye(N, M=N, k=0) -- двумерный массив с N строками с единицами на диагонали и нулями во всех остальных позициях. Число столбцов M по умолчанию равно N, k — сдвиг диагонали (0 для основной диагонали, положительные числа для верхних диагоналей и отрицательные для нижних),
# zeros(shape) -- новый массив указанной формы, заполненный нулями,
# ones(shape) -- новый массив указанной формы, заполненный единицами,
# full(shape, fill_value) -- новый массив указанной формы, заполненный fill_value.

# print(np.eye(5, 3, k=-1))

# в NumPy используется стандартное  выделение подмножеств:
# a[start:stop:step] выбирает элементы из a с индексами от start до stop с шагом step,
# т.е. a[start], a[start + step], a[start + 2*step] и так далее,
# пока индексы меньше stop; при step = 1 этот параметр можно опустить,
# оставив start:stop, при start, равном минимальному индексу в массиве, или stop, равному максимальному индексу,
# эти индексы также можно опустить: это будет выглядеть как a[:];
# отрицательные индексы;
# поддерживается синтаксис многоточия: a[..., 1] выбирает элементы с любым индексом в первом измерении и с индексом, равным 1, во втором измерении:  a[:, 1] оказывается эквивалентно a[..., 1];
# можно указать индексы сразу в нескольких измерениях, указав их через запятую в квадратных скобках (как a[..., 1] в примере выше).

a = np.array([[1,2,3], [4,5,6]])  # создаём массив
print(a)  # смотрим на массив
print(a.shape)  # смотрим на форму массива
mat = np.eye(3, 4, 1) + (np.eye(3, 4)*2)
print(mat);

# a.flatten() — превращает массив в одномерный.
# a.T или a.transpose(*axes) — транспонирование (или смена порядка осей в случае, когда размерность массива больше двух).
# a.reshape(shape) — смена формы массива. Массив "распрямляется" и построчно заполняется в новую форму.

# import random
# w = np.array(random.sample(range(1000), 12))
# print(w.reshape((2,2,3))) # превратим w в трёхмерную матрицу
# print(w.transpose(0,2,1))

mat = mat.flatten()

print('mat: ', mat.size)
print('shape: ', mat.reshape(mat.size, 1));

# a.min(axis=None), a.max(axis=None), — минимум, максимум,
# a.mean(axis=None), a.std(axis=None) - среднее арифметическое и стандартное отклонение вдоль указанной оси.
# По умолчанию ось не указана и статистика считается по всему массиву.
# a.argmin(axis=None), a.argmax(axis=None) — индексы минимального и максимального элемента.

v = np.array([ [1,2,3], [4,5,6], [7,8,9] ])

print(v.mean(axis=0))  # вдоль столбцов
print(v.mean(axis=1))
print(v.mean(axis=None));

# a.sum(axis=None), a.prod(axis=None) — сумма и произведение всех элементов вдоль указанной оси.
# a.cumsum(axis=None), a.cumprod(axis=None) — частичные суммы и произведения (для (a1,⋯,an)(a1,⋯,an)
# вектор частичных сумм — это (a1,a1+a2,⋯,a1+⋯+an)(a1,a1+a2,⋯,a1+⋯+an)).

# a.dot(b) — матричное произведение двух массивов (размерности должны быть согласованы),
# linalg.matrix_power(M, n) — возведение матрицы M в степень n,
# a.T — транспонирование
# linalg.norm(a, ord=None) — норма матрицы
# linalg.inv(a) — матрица, обратная к a (если a необратима, выбрасывается LinAlgError; псевдообратная считается через linalg.pinv(a))

x_shape = tuple(map(int, input().split()))
X = np.fromiter(map(int, input().split()), np.int).reshape(x_shape)

# map(f, iterable, …) — встроенная функция языка Python,
# возвращает результат поэлементного применения функции f к элементам последовательности iterable;
# если f принимает несколько аргументов, то на вход должно быть подано соответствующее число последовательностей:
# результатом map(f, x, y, z) будет итератор, возвращающий поочерёдно
# f(x[0], y[0], z[0]), f(x[1], y[1], z[1]), f(x[2], y[2], z[2]) и так далее;
# результат применения f к очередному набору аргументов вычисляется только тогда,
# когда требуется использовать этот результат, но не ранее

# np.fromiter создаёт NumPy-массив из итератора,
# то есть заставляет итератор вычислить все доступные значения и сохраняет их в массив;
# input() — встроенная функция языка Python, читает одну строку
# (последовательность символов вплоть до символа переноса строки) из входного потока данных и возвращает её как строку;
# split() — метод класса string, возвращает список слов в строке
# (здесь слова — последовательности символов, разделённые пробельными символами); принимает дополнительные аргументы

sbux = np.loadtxt("sbux.csv", usecols=(0,1,4), skiprows=1, delimiter=",",
                      dtype={'names': ('date', 'open', 'close'),
                             'formats': ('datetime64[D]', 'f4', 'f4')})
print(sbux[0:4])
# [(datetime.date(2015, 9, 1), 53.0, 57.2599983215332)
#  (datetime.date(2015, 8, 3), 58.619998931884766, 54.709999084472656)
#  (datetime.date(2015, 7, 1), 53.86000061035156, 57.93000030517578)
#  (datetime.date(2015, 6, 1), 51.959999084472656, 53.619998931884766)]

# "sbux.csv" — имя файла (или сюда же можно передать объект файла, такой пример вы увидите в следующей задаче урока),
# из которого считываются данные.
# usecols — список колонок, которые нужно использовать. Если параметр не указан, считываются все колонки.
# skiprows — количество рядов в начале файла, которые нужно пропустить. В нашем случае пропущен ряд заголовков.
# По умолчанию (если значение параметра не указано явно) skiprows = 0.
# delimiter — разделитель столбцов в одной строке, в csv-файлах это запятая,
# по умолчанию разделителем является любой пробел (в том числе — знак табуляции).
# dtype — словарь из названий колонок (переменных) и типов хранящихся в них значений.
# NumPy использует свою собственную систему типов, и названия именно этих типов нужно указать.
# По умолчанию функция попытается самостоятельно угадать, какому типу принадлежат подаваемые на вход значения.

from urllib.request import urlopen
f = urlopen('https://stepic.org/media/attachments/lesson/16462/boston_houses.csv')